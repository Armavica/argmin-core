initSidebarItems({"enum":[["ArgminError",""],["CheckpointMode",""],["TerminationReason","Indicates why the optimization algorithm stopped"]],"fn":[["load_checkpoint",""]],"macro":[["check_param","Release an `T` from an `Option<T>` if it is not `None`. If it is `None`, return an `ArgminError` with a message that needs to be provided."],["make_kv","Creates an `ArgminKV` at compile time in order to avoid pushing to the `kv` vector."]],"mod":[["finitediff","Finite Differentiation"],["macros","Macros # Macros"],["modcholesky","Modified Cholesky decompositions Modified Cholesky decompositions"]],"struct":[["ArgminBase","Storage for data needed by most solvers"],["ArgminCheckpoint",""],["ArgminIterationData","The datastructure which is returned by the `next_iter` method of the `ArgminNextIter` trait."],["ArgminKV","A simple key-value storage"],["ArgminLogger","Container for `ArgminLog`gers"],["ArgminResult","Return struct for all solvers."],["ArgminSlogLogger","A logger based on `slog`"],["ArgminWriter",""],["Error","The `Error` type, which can contain any failure."],["MinimalNoOperator",""],["NoOperator",""],["WriteToFile",""]],"trait":[["ArgminAdd","Add a `T` to `self`"],["ArgminDiv","(Pointwise) Divide a `T` by `self`"],["ArgminDot","Dot/scalar product of `T` and `self`"],["ArgminEye",""],["ArgminInv","Compute the inverse (`T`) of `self`"],["ArgminLineSearch","Defines a common interface to line search methods. Requires that `ArgminSolver` is implemented for the line search method as well."],["ArgminLog","Defince the interface every logger needs to expose"],["ArgminMul","(Pointwise) Multiply a `T` with `self`"],["ArgminNLCGBetaUpdate","Every method for the update of beta needs to implement this trait."],["ArgminNextIter","Main part of every solver: `next_iter` computes one iteration of the algorithm and `init` is executed before these iterations. The `init` method comes with a default implementation which corresponds to doing nothing."],["ArgminNorm","Compute the l2-norm (`U`) of `self`"],["ArgminOperator","This trait needs to be implemented for every operator/cost function."],["ArgminScaledAdd","Add a `T` scaled by an `U` to `self`"],["ArgminScaledSub","Subtract a `T` scaled by an `U` from `self`"],["ArgminSolver","Defines the interface to a solver. Usually, there is no need to implement this manually, use the `argmin_derive` crate instead."],["ArgminSub","Subtract a `T` from `self`"],["ArgminTranspose",""],["ArgminTrustRegion","Defines a common interface to methods which calculate approximate steps for trust region methods. Requires that `ArgminSolver` is implemented as well."],["ArgminWeightedDot","Dot/scalar product of `T` and `self` weighted by W (p^TWv)"],["ArgminWrite","Every writer (which is something that writes parameter vectors somewhere after each iteration) needs to implement this."],["ArgminZero","Return param vector of all zeros (for now, this is a hack. It should be done better)"]]});