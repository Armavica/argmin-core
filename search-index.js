var N=null,E="",T="t",U="u",searchIndex={};
var R=["argmin_core","argmin_core::ArgminError","Aborted","Always","argminkv","Return the gradient evaluation count","termination_reason","terminationreason","terminated","result","duration","Constructor","argminlog","argminwrite","checkpointmode","set_mode","arraybase","argmin_core::modcholesky","decomposition","WriteToFile","WriteToFileSerializer","Calculation of the Jacobian J(x) of a vector function `fs`…","Calculation of the product of the Jacobian J(x) of a…","Calculation of the product of the Hessian H(x) of a…","Dot/scalar product of `T` and `self`","Return zero(s)","Add a `T` to `self`","Subtract a `T` from `self`","(Pointwise) Multiply a `T` with `self`","(Pointwise) Divide a `T` by `self`","Add a `T` scaled by an `U` to `self`","Subtract a `T` scaled by an `U` from `self`","Compute the l2-norm (`U`) of `self`","gradient","cur_param","cur_grad","cur_hessian","return current gradient","set_cur_param","set_cur_grad","set_cur_hessian","set current gradient","set_best_param","set current parameter vector","argminresult","set_termination_reason","set_max_iters","max_iters","cur_iter","increment_iter","cur_cost","set_cur_cost","Get current cost function value","best_cost","set_best_cost","set_target_cost","add_logger","add_writer","increment_cost_func_count","Increment the cost function evaluation count","increase_cost_func_count","Increaese the cost function evaluation count by a given…","cost_func_count","Return the cost function evaluation count","increment_grad_func_count","Increment the gradient evaluation count","increase_grad_func_count","Increase the gradient evaluation count by a given value","grad_func_count","increment_hessian_func_count","Increment the hessian evaluation count","increase_hessian_func_count","Increase the hessian evaluation count by a given value","hessian_func_count","set_checkpoint_dir","Set checkpoint directory","set_checkpoint_name","Set checkpoint name","set_checkpoint_mode","Hessian","log_info","log_iter","hessian","Set the initial step length","Set the gradient at the starting point","try_from","borrow_mut","try_into","to_string","string","to_owned","clone_into","type_id","borrow","typeid","argmin_core::finitediff","as_fail","formatter","perturbationvector","Log general info","This should be used to log iteration data only (because…","writetofileserializer","writetofile","writermode","argmincheckpoint","default","ordering","argminlogger","nooperator","minimalnooperator","argminwriter","partial_cmp","serialize","deserialize","backtrace","Attempts to downcast this `Error` to a particular `Fail`…","mod_cholesky_gmw81","Computes the modified Cholesky decomposition with the…","mod_cholesky_se99","Computes the modified Cholesky decomposition with the SE99…","mod_cholesky_se90","Computes the modified Cholesky decomposition with the SE90…","ArgminResult","ArgminError","WriterMode","TerminationReason","CheckpointMode","ArgminBase","ArgminSlogLogger","ArgminLogger","NoOperator","MinimalNoOperator","ArgminWriter","ArgminCheckpoint","Decomposition","GershgorinCircles","ModCholeskyGMW81","ModCholeskySE99","ModCholeskySE90","FiniteDiff","PerturbationVector","ArgminDot","ArgminWeightedDot","ArgminZero","ArgminEye","ArgminAdd","ArgminSub","ArgminMul","ArgminDiv","ArgminScaledAdd","ArgminScaledSub","ArgminNorm","ArgminTranspose","ArgminInv","ArgminSolver","ArgminIter","ArgminLog","ArgminWrite","ArgminLineSearch","ArgminTrustRegion","ArgminNLCGBetaUpdate","ArgminIterData"];

searchIndex[R[0]]={"doc":"Argmin Optimizaton toolbox core","i":[[3,"Error",R[0],"The `Error` type, which can contain any failure.",N,N],[3,R[127],E,"Storage for data needed by most solvers",N,N],[3,"ArgminKV",E,"A simple key-value storage",N,N],[12,"kv",E,"The actual key value storage",0,N],[3,R[128],E,"A logger based on `slog`",N,N],[3,R[129],E,"Container for `ArgminLog`gers",N,N],[3,R[130],E,E,N,N],[3,R[131],E,E,N,N],[3,R[19],E,E,N,N],[3,R[132],E,E,N,N],[3,R[122],E,"Return struct for all solvers.",N,N],[12,"param",E,"Final parameter vector",1,N],[12,"cost",E,"Final cost value",1,N],[12,"iters",E,"Number of iterations",1,N],[12,R[8],E,"Indicated whether it terminated or not",1,N],[12,R[6],E,"Reason of termination",1,N],[3,R[133],E,E,N,N],[3,R[161],E,"The datastructure which is returned by the `next_iter`…",N,N],[4,R[123],E,E,N,N],[13,"InvalidParameter",E,"Indicates and invalid parameter",2,N],[12,"text",R[1],E,2,N],[13,"NotImplemented",R[0],"Indicates that a function is not implemented",2,N],[12,"text",R[1],E,2,N],[13,"NotInitialized",R[0],"Indicates that a function is not initialized",2,N],[12,"text",R[1],E,2,N],[13,"ConditionViolated",R[0],"Indicates that a condition is violated",2,N],[12,"text",R[1],E,2,N],[13,"CheckpointNotFound",R[0],"Checkpoint was not found",2,N],[12,"text",R[1],E,2,N],[13,"ImpossibleError",R[0],"Indicates an impossible error",2,N],[12,"text",R[1],E,2,N],[4,R[20],R[0],E,N,N],[13,"Bincode",E,E,3,N],[13,"JSON",E,E,3,N],[4,R[124],E,E,N,N],[13,"Never",E,E,4,N],[13,R[3],E,E,4,N],[13,"Every",E,E,4,N],[13,"NewBest",E,E,4,N],[4,R[125],E,"Indicates why the optimization algorithm stopped",N,N],[13,"NotTerminated",E,"In case it has not terminated yet",5,N],[13,"MaxItersReached",E,"Maximum number of iterations reached",5,N],[13,"TargetCostReached",E,"Target cost function value reached",5,N],[13,"TargetPrecisionReached",E,"Target precision reached",5,N],[13,"AcceptedStallIterExceeded",E,"Acceped stall iter exceeded",5,N],[13,"BestStallIterExceeded",E,"Best stall iter exceeded",5,N],[13,"LineSearchConditionMet",E,"Condition for Line search met",5,N],[13,R[2],E,R[2],5,N],[4,R[126],E,E,N,N],[13,"Never",E,E,6,N],[13,"Every",E,E,6,N],[13,R[3],E,E,6,N],[5,"load_checkpoint",E,E,N,[[["p"]],[R[9],["error"]]]],[0,"macros",E,"Macros # Macros",N,N],[11,"new",E,R[11],7,N],[11,"kv_for_logs",E,"Return the KV for the initial logging",7,[[["self"]],[R[4]]]],[11,"kv_for_iter",E,"Return the KV for logging of the iterations",7,[[["self"]],[R[4]]]],[11,"reset",E,"Reset `self` to its initial state.",7,[[["self"]]]],[11,"apply",E,"Apply the operator to `param`",7,N],[11,R[33],E,"Compute the gradient at `param`",7,N],[11,R[82],E,"Compute the hessian at `param`",7,N],[11,"modify",E,"Modify a `param` with the `modify` method of `operator`.",7,N],[11,R[38],E,"Set the current parameter vector",7,N],[11,R[34],E,"Return the current parameter vector",7,N],[11,R[42],E,"Set the new best parameter vector",7,N],[11,"best_param",E,"Return the current best parameter vector",7,N],[11,R[51],E,"Set the current cost function value",7,[[["self"],["f64"]],["self"]]],[11,R[50],E,"Return the current cost function value",7,[[["self"]],["f64"]]],[11,R[54],E,"Set the cost function value of the current best parameter…",7,[[["self"],["f64"]],["self"]]],[11,R[53],E,"Return the cost function value of the current best…",7,[[["self"]],["f64"]]],[11,R[39],E,"Set the current gradient",7,N],[11,R[35],E,"Return the current gradient",7,N],[11,R[40],E,"Set the current hessian",7,N],[11,R[36],E,"Return the current hessian",7,N],[11,R[55],E,"Set the target cost function value",7,[[["self"],["f64"]],["self"]]],[11,"target_cost",E,"Return the target cost function value",7,[[["self"]],["f64"]]],[11,R[49],E,"Increment the number of iterations.",7,[[["self"]],["self"]]],[11,R[48],E,"Return the current number of iterations",7,[[["self"]],["u64"]]],[11,R[58],E,R[59],7,[[["self"]],["self"]]],[11,R[60],E,R[61],7,[[["self"],["u64"]],["self"]]],[11,R[62],E,R[63],7,[[["self"]],["u64"]]],[11,R[64],E,R[65],7,[[["self"]],["self"]]],[11,R[66],E,R[67],7,[[["self"],["u64"]],["self"]]],[11,R[68],E,R[5],7,[[["self"]],["u64"]]],[11,R[69],E,R[70],7,[[["self"]],["self"]]],[11,R[71],E,R[72],7,[[["self"],["u64"]],["self"]]],[11,R[73],E,R[5],7,[[["self"]],["u64"]]],[11,R[46],E,"Set the maximum number of iterations.",7,[[["self"],["u64"]],["self"]]],[11,R[47],E,"Return the maximum number of iterations",7,[[["self"]],["u64"]]],[11,R[45],E,"Set the `TerminationReason`",7,[[["self"],[R[7]]],["self"]]],[11,R[6],E,"Return the `TerminationReason`",7,[[["self"]],[R[7]]]],[11,"termination_reason_text",E,"Return the textual representation of the `TerminationReason`",7,[[["self"]],["str"]]],[11,R[8],E,"Return whether the algorithm has terminated or not",7,[[["self"]],["bool"]]],[11,R[9],E,"Return the result.",7,[[["self"]],[R[44]]]],[11,"set_total_time",E,"Set the total time needed by the solver",7,[[["self"],[R[10]]],["self"]]],[11,"total_time",E,"Return the total time",7,[[["self"]],[R[10]]]],[11,R[56],E,"Add a logger to the list of loggers",7,[[["self"],["arc",[R[12]]]],["self"]]],[11,R[57],E,"Add a writer to the list of writers",7,[[["self"],["arc",[R[13]]]],["self"]]],[11,R[81],E,"Log a `kv`",7,[[["self"],[R[4]]],[R[9],["error"]]]],[11,R[80],E,"Log a message and a `kv`",7,[[["self"],["str"],[R[4]]],[R[9],["error"]]]],[11,"write",E,"Write",7,N],[11,R[74],E,R[75],7,[[["self"],["str"]]]],[11,R[76],E,R[77],7,[[["self"],["str"]]]],[11,R[78],E,E,7,[[["self"],[R[14]]]]],[11,"store_checkpoint",E,E,7,[[["self"],[T]],[R[9],["error"]]]],[11,"new",E,R[11],0,[[],["self"]]],[11,"push",E,"Push a key-value pair to the `kv` vector.",0,[[["self"],["str"],[T]],["self"]]],[11,"merge",E,"Merge another `kv` into `self.kv`",0,[[["self"],[R[4]]],["self"]]],[11,"term",E,"Log to the terminal in a blocking way",8,[[],["arc"]]],[11,"term_noblock",E,"Log to the terminal in a non-blocking way (in case of…",8,[[],["arc"]]],[11,"file",E,"Log JSON to a file in a blocking way",8,[[["str"]],[R[9],["arc","error"]]]],[11,"file_noblock",E,"Log JSON to a file in a non-blocking way (in case of…",8,[[["str"]],[R[9],["arc","error"]]]],[11,"new",E,R[11],9,[[],["self"]]],[11,"push",E,"Push another `ArgminLog` to the `logger` field",9,[[["self"],["arc",[R[12]]]],["self"]]],[11,"new",E,E,10,[[],["self"]]],[11,"new",E,E,11,[[],["self"]]],[11,"new",E,E,12,[[["str"],["str"]],["self"]]],[11,"set_serializer",E,E,12,[[["self"],[R[101]]],["self"]]],[11,R[15],E,E,12,[[["self"],[R[103]]],["self"]]],[11,"new",E,E,13,[[],["self"]]],[11,"push",E,E,13,[[["self"],["arc",[R[13]]]],["self"]]],[11,"new",E,R[11],1,[[[T],["f64"],["u64"],[R[7]]],["self"]]],[11,"new",E,E,14,[[["str"],[R[14]]],[R[9],["error"]]]],[11,"set_dir",E,E,14,[[["self"],["str"]]]],[11,"dir",E,E,14,[[["self"]],[R[89]]]],[11,"set_name",E,E,14,[[["self"],["str"]]]],[11,"name",E,E,14,[[["self"]],[R[89]]]],[11,R[15],E,E,14,[[["self"],[R[14]]]]],[11,"store",E,E,14,[[["self"],[T],[R[89]]],[R[9],["error"]]]],[11,"store_cond",E,E,14,[[["self"],[T],["u64"]],[R[9],["error"]]]],[11,R[8],E,"Returns `true` if a solver terminated and `false` otherwise",5,[[["self"]],["bool"]]],[11,"text",E,"Returns a texual representation of what happened",5,[[["self"]],["str"]]],[0,"modcholesky",E,"Modified Cholesky decompositions Modified Cholesky…",N,N],[0,"utils",R[17],"Utility functions",N,N],[5,"eigenvalues_2x2","argmin_core::modcholesky::utils","Computes the Eigenvalues of a 2x2 matrix",N,N],[5,"swap_columns",E,"Swaps columns `idx1` and `idx2` of matrix `mat`",N,N],[5,"swap_rows",E,"Swaps rows `idx1` and `idx2` of matrix `mat`",N,N],[5,"index_of_largest",E,"Returns the index of the largest element in a 1D array",N,[[[R[16]]],["usize"]]],[5,"index_of_largest_abs",E,"Returns the index of the element with the largest absolute…",N,[[[R[16]]],["usize"]]],[5,"index_to_permutation_mat",E,"Returns the permutation matrix for a vector of permuted…",N,N],[5,"diag_mat_from_arr",E,"Builds a diagonal matrix from a 1D slice",N,N],[5,"random_householder",E,"Returns a random Householder matrix of dimension `dim` and…",N,[[["usize"],["u8"]],[R[16],["ownedrepr","dim"]]]],[5,"random_diagonal",E,"Returns a random diagonal matrix with Eigenvalues…",N,N],[3,R[134],R[17],E,N,N],[12,"l",E,E,15,N],[12,"e",E,E,15,N],[12,"p",E,E,15,N],[8,R[135],E,"Gershgorin circles",N,N],[10,"gershgorin_circles",E,"Computes the Gershgorin Circles of a matrix",16,[[["self"]],["vec"]]],[8,R[136],E,"Gill, Murray and Wright (1981)",N,N],[11,R[116],E,R[117],17,[[["self"]],[R[18]]]],[8,R[137],E,"Schnabel & Eskow algorithm (1999)",N,N],[11,R[118],E,R[119],18,[[["self"]],[R[18]]]],[8,R[138],E,"Schnabel & Eskow algorithm (1990)",N,N],[11,R[120],E,R[121],19,[[["self"]],[R[18]]]],[0,"file",R[0],"Output parameter vectors to file",N,N],[3,R[19],"argmin_core::file",E,N,N],[4,R[20],E,E,N,N],[13,"Bincode",E,E,3,N],[13,"JSON",E,E,3,N],[0,"finitediff",R[0],"Finite Differentiation",N,N],[8,R[139],R[95],E,N,N],[16,"Jacobian",E,E,20,N],[16,R[79],E,E,20,N],[16,"OperatorOutput",E,E,20,N],[10,"forward_diff",E,"Forward difference calculated as",20,[[["self"],["fn"]],["self"]]],[10,"central_diff",E,"Central difference calculated as",20,[[["self"],["fn"]],["self"]]],[10,"forward_jacobian",E,R[21],20,N],[10,"central_jacobian",E,R[21],20,N],[10,"forward_jacobian_vec_prod",E,R[22],20,[[["self"],["fn"],["self"]],["self"]]],[10,"central_jacobian_vec_prod",E,R[22],20,[[["self"],["fn"],["self"]],["self"]]],[10,"forward_jacobian_pert",E,E,20,N],[10,"central_jacobian_pert",E,E,20,N],[10,"forward_hessian",E,"Calculation of the Hessian using forward differences",20,N],[10,"central_hessian",E,"Calculation of the Hessian using central differences",20,N],[10,"forward_hessian_vec_prod",E,R[23],20,[[["self"],["fn"],["self"]],["self"]]],[10,"central_hessian_vec_prod",E,R[23],20,[[["self"],["fn"],["self"]],["self"]]],[10,"forward_hessian_nograd",E,"Calculation of the Hessian using forward differences…",20,N],[10,"forward_hessian_nograd_sparse",E,"Calculation of a sparse Hessian using forward differences…",20,N],[3,R[140],E,"Perturbation Vector for the accelerated computation of the…",N,N],[12,"x_idx",E,"x indices",21,N],[12,"r_idx",E,"correspoding function indices",21,N],[6,"PerturbationVectors",E,"A collection of `PerturbationVector`s",N,N],[8,R[141],R[0],R[24],N,N],[10,"dot",E,R[24],22,[[["self"],[T]],[U]]],[8,R[142],E,"Dot/scalar product of `T` and `self` weighted by W (p^TWv)",N,N],[10,"weighted_dot",E,R[24],23,[[["self"],["v"],[T]],[U]]],[8,R[143],E,"Return param vector of all zeros (for now, this is a hack.…",N,N],[10,"zero_like",E,R[25],24,[[["self"]],["self"]]],[10,"zero",E,R[25],24,[[],["self"]]],[8,R[144],E,E,N,N],[10,"eye",E,E,25,[[["usize"]],["self"]]],[10,"eye_like",E,E,25,[[["self"]],["self"]]],[8,R[145],E,R[26],N,N],[10,"add",E,R[26],26,[[["self"],[T]],[U]]],[8,R[146],E,R[27],N,N],[10,"sub",E,R[27],27,[[["self"],[T]],[U]]],[8,R[147],E,R[28],N,N],[10,"mul",E,R[28],28,[[["self"],[T]],[U]]],[8,R[148],E,R[29],N,N],[10,"div",E,R[29],29,[[["self"],[T]],[U]]],[8,R[149],E,R[30],N,N],[10,"scaled_add",E,R[30],30,[[["self"],[U],[T]],["v"]]],[8,R[150],E,R[31],N,N],[10,"scaled_sub",E,R[31],31,[[["self"],[U],[T]],["v"]]],[8,R[151],E,R[32],N,N],[10,"norm",E,R[32],32,[[["self"]],[U]]],[8,R[152],E,E,N,N],[10,T,E,E,33,[[["self"]],["self"]]],[8,R[153],E,"Compute the inverse (`T`) of `self`",N,N],[10,"inv",E,E,34,[[["self"]],[R[9],["error"]]]],[8,R[154],E,"Defines the interface to a solver. Usually, there is no…",N,N],[11,"from_checkpoint",E,"Load solver from checkpoint",35,[[["p"]],[R[9],["error"]]]],[10,"apply",E,"apply cost function or operator to a parameter vector",35,N],[10,R[33],E,"compute the gradient for a parameter vector",35,N],[10,R[82],E,"compute the hessian for a parameter vector",35,N],[10,"modify",E,"modify the parameter vector",35,N],[10,R[34],E,"return current parameter vector",35,N],[10,R[35],E,R[37],35,N],[10,R[36],E,R[37],35,N],[10,R[38],E,R[43],35,N],[10,R[39],E,R[41],35,N],[10,R[40],E,R[41],35,N],[10,R[42],E,R[43],35,N],[10,"run",E,"Execute the optimization algorithm.",35,[[["self"]],[R[9],[R[44],"error"]]]],[10,"run_fast",E,"Execute the optimization algorithm without Ctrl-C…",35,[[["self"]],[R[9],[R[44],"error"]]]],[10,R[9],E,"Returns the best solution found during optimization.",35,[[["self"]],[R[44]]]],[10,R[45],E,"Set termination reason (doesn't terminate yet! -- this is…",35,[[["self"],[R[7]]]]],[10,"terminate",E,"Evaluate all stopping criterions and return the…",35,[[["self"]],[R[7]]]],[10,R[46],E,"Set max number of iterations.",35,[[["self"],["u64"]]]],[10,R[47],E,"Get max number of iterations.",35,[[["self"]],["u64"]]],[10,R[48],E,"Get current iteration number.",35,[[["self"]],["u64"]]],[10,R[49],E,"Increment the iteration number by one",35,[[["self"]]]],[10,R[50],E,R[52],35,[[["self"]],["f64"]]],[10,R[51],E,R[52],35,[[["self"],["f64"]]]],[10,R[53],E,"Get best cost function value",35,[[["self"]],["f64"]]],[10,R[54],E,"set best cost value",35,[[["self"],["f64"]]]],[10,R[55],E,"Set the target cost function value which is used as a…",35,[[["self"],["f64"]]]],[10,R[56],E,"Add a logger to the array of loggers",35,[[["self"],["arc",[R[12]]]]]],[10,R[57],E,"Add a writer to the array of writers",35,[[["self"],["arc",[R[13]]]]]],[10,"base_reset",E,"Reset the base of the algorithm to its initial state",35,[[["self"]]]],[10,R[58],E,R[59],35,[[["self"]]]],[10,R[60],E,R[61],35,[[["self"],["u64"]]]],[10,R[62],E,R[63],35,[[["self"]],["u64"]]],[10,R[64],E,R[65],35,[[["self"]]]],[10,R[66],E,R[67],35,[[["self"],["u64"]]]],[10,R[68],E,R[5],35,[[["self"]],["u64"]]],[10,R[69],E,R[70],35,[[["self"]]]],[10,R[71],E,R[72],35,[[["self"],["u64"]]]],[10,R[73],E,R[5],35,[[["self"]],["u64"]]],[10,R[74],E,R[75],35,[[["self"],["str"]]]],[10,R[76],E,R[77],35,[[["self"],["str"]]]],[10,R[78],E,"Set checkpoint mode",35,[[["self"],[R[14]]]]],[8,R[155],E,"Main part of every solver: `next_iter` computes one…",N,N],[16,"Param",E,"Parameter vectors",36,N],[16,"Output",E,"Output of the operator",36,N],[16,R[79],E,R[79],36,N],[10,"next_iter",E,"Computes one iteration of the algorithm.",36,[[["self"]],[R[9],["argminiterdata","error"]]]],[11,"init",E,"Initializes the algorithm",36,[[["self"]],[R[9],["error"]]]],[8,R[156],E,"Defince the interface every logger needs to expose",N,N],[10,R[80],E,"Logs general information (a message `msg` and/or key-value…",37,[[["self"],["str"],[R[4]]],[R[9],["error"]]]],[10,R[81],E,"Logs information from iterations. Only accepts key-value…",37,[[["self"],[R[4]]],[R[9],["error"]]]],[8,R[157],E,"Every writer (which is something that writes parameter…",N,N],[16,"Param",E,E,38,N],[10,"write",E,"Writes the parameter vector somewhere",38,N],[8,"ArgminOp",E,"This trait needs to be implemented for every operator/cost…",N,N],[16,"Param",E,"Type of the parameter vector",39,N],[16,"Output",E,"Output of the operator. Most solvers expect `f64`.",39,N],[16,R[79],E,"Type of Hessian",39,N],[11,"apply",E,"Applies the operator/cost function to parameters",39,N],[11,R[33],E,"Computes the gradient at the given parameters",39,N],[11,R[82],E,"Computes the hessian at the given parameters",39,N],[11,"modify",E,"Modifies a parameter vector. Comes with a variable that…",39,N],[8,R[158],E,"Defines a common interface to line search methods.…",N,N],[10,"set_initial_parameter",E,"Set the initial parameter (starting point)",40,N],[10,"set_search_direction",E,"Set the search direction",40,N],[10,"set_initial_alpha",E,R[83],40,[[["self"],["f64"]],[R[9],["error"]]]],[10,"set_initial_cost",E,"Set the cost function value at the starting point as…",40,[[["self"],["f64"]]]],[10,"set_initial_gradient",E,"Set the gradient at the starting point as opposed to…",40,N],[10,"calc_initial_cost",E,"calculate the initial cost function value using an…",40,[[["self"]],[R[9],["error"]]]],[10,"calc_initial_gradient",E,"calculate the initial gradient using an operator as…",40,[[["self"]],[R[9],["error"]]]],[8,R[159],E,"Defines a common interface to methods which calculate…",N,N],[10,"set_radius",E,R[83],41,[[["self"],["f64"]]]],[10,"set_grad",E,R[84],41,N],[10,"set_hessian",E,R[84],41,N],[8,R[160],E,"Every method for the update of beta needs to implement…",N,N],[10,"update",E,"Update beta Parameter 1: \\nabla f_k Parameter 2: \\nabla…",42,[[["self"],[T],[T],[T]],["f64"]]],[11,"new",E,R[11],43,[[[T],["f64"]],["self"]]],[11,"param",E,"Returns the parameter vector",43,[[["self"]],[T]]],[11,"cost",E,"Returns the cost function value",43,[[["self"]],["f64"]]],[11,"add_kv",E,"Adds an `ArgminKV`",43,[[["self"],[R[4]]],["self"]]],[11,"get_kv",E,"Returns an `ArgminKV`",43,[[["self"]],["option",[R[4]]]]],[14,"make_kv",E,"Creates an `ArgminKV` at compile time in order to avoid…",N,N],[14,"check_param",E,"Release an `T` from an `Option<T>` if it is not `None`. If…",N,N],[11,R[88],E,E,44,[[["self"]],[R[89]]]],[11,"from",E,E,44,[[[T]],[T]]],[11,"into",E,E,44,[[["self"]],[U]]],[11,R[85],E,E,44,[[[U]],[R[9]]]],[11,R[93],E,E,44,[[["self"]],[T]]],[11,R[92],E,E,44,[[["self"]],[R[94]]]],[11,R[86],E,E,44,[[["self"]],[T]]],[11,R[87],E,E,44,[[["self"]],[R[9]]]],[11,R[96],E,E,44,[[["self"]],["fail"]]],[11,"from",E,E,7,[[[T]],[T]]],[11,"into",E,E,7,[[["self"]],[U]]],[11,R[90],E,E,7,[[["self"]],[T]]],[11,R[91],E,E,7,N],[11,R[85],E,E,7,[[[U]],[R[9]]]],[11,R[93],E,E,7,[[["self"]],[T]]],[11,R[92],E,E,7,[[["self"]],[R[94]]]],[11,R[86],E,E,7,[[["self"]],[T]]],[11,R[87],E,E,7,[[["self"]],[R[9]]]],[11,R[88],E,E,0,[[["self"]],[R[89]]]],[11,"from",E,E,0,[[[T]],[T]]],[11,"into",E,E,0,[[["self"]],[U]]],[11,R[90],E,E,0,[[["self"]],[T]]],[11,R[91],E,E,0,N],[11,R[85],E,E,0,[[[U]],[R[9]]]],[11,R[93],E,E,0,[[["self"]],[T]]],[11,R[92],E,E,0,[[["self"]],[R[94]]]],[11,R[86],E,E,0,[[["self"]],[T]]],[11,R[87],E,E,0,[[["self"]],[R[9]]]],[11,"from",E,E,8,[[[T]],[T]]],[11,"into",E,E,8,[[["self"]],[U]]],[11,R[90],E,E,8,[[["self"]],[T]]],[11,R[91],E,E,8,N],[11,R[85],E,E,8,[[[U]],[R[9]]]],[11,R[93],E,E,8,[[["self"]],[T]]],[11,R[92],E,E,8,[[["self"]],[R[94]]]],[11,R[86],E,E,8,[[["self"]],[T]]],[11,R[87],E,E,8,[[["self"]],[R[9]]]],[11,"from",E,E,9,[[[T]],[T]]],[11,"into",E,E,9,[[["self"]],[U]]],[11,R[90],E,E,9,[[["self"]],[T]]],[11,R[91],E,E,9,N],[11,R[85],E,E,9,[[[U]],[R[9]]]],[11,R[93],E,E,9,[[["self"]],[T]]],[11,R[92],E,E,9,[[["self"]],[R[94]]]],[11,R[86],E,E,9,[[["self"]],[T]]],[11,R[87],E,E,9,[[["self"]],[R[9]]]],[11,"from",E,E,10,[[[T]],[T]]],[11,"into",E,E,10,[[["self"]],[U]]],[11,R[90],E,E,10,[[["self"]],[T]]],[11,R[91],E,E,10,N],[11,R[85],E,E,10,[[[U]],[R[9]]]],[11,R[93],E,E,10,[[["self"]],[T]]],[11,R[92],E,E,10,[[["self"]],[R[94]]]],[11,R[86],E,E,10,[[["self"]],[T]]],[11,R[87],E,E,10,[[["self"]],[R[9]]]],[11,"from",E,E,11,[[[T]],[T]]],[11,"into",E,E,11,[[["self"]],[U]]],[11,R[90],E,E,11,[[["self"]],[T]]],[11,R[91],E,E,11,N],[11,R[85],E,E,11,[[[U]],[R[9]]]],[11,R[93],E,E,11,[[["self"]],[T]]],[11,R[92],E,E,11,[[["self"]],[R[94]]]],[11,R[86],E,E,11,[[["self"]],[T]]],[11,R[87],E,E,11,[[["self"]],[R[9]]]],[11,"from",E,E,12,[[[T]],[T]]],[11,"into",E,E,12,[[["self"]],[U]]],[11,R[90],E,E,12,[[["self"]],[T]]],[11,R[91],E,E,12,N],[11,R[85],E,E,12,[[[U]],[R[9]]]],[11,R[93],E,E,12,[[["self"]],[T]]],[11,R[92],E,E,12,[[["self"]],[R[94]]]],[11,R[86],E,E,12,[[["self"]],[T]]],[11,R[87],E,E,12,[[["self"]],[R[9]]]],[11,"from",E,E,13,[[[T]],[T]]],[11,"into",E,E,13,[[["self"]],[U]]],[11,R[90],E,E,13,[[["self"]],[T]]],[11,R[91],E,E,13,N],[11,R[85],E,E,13,[[[U]],[R[9]]]],[11,R[93],E,E,13,[[["self"]],[T]]],[11,R[92],E,E,13,[[["self"]],[R[94]]]],[11,R[86],E,E,13,[[["self"]],[T]]],[11,R[87],E,E,13,[[["self"]],[R[9]]]],[11,R[88],E,E,1,[[["self"]],[R[89]]]],[11,"from",E,E,1,[[[T]],[T]]],[11,"into",E,E,1,[[["self"]],[U]]],[11,R[90],E,E,1,[[["self"]],[T]]],[11,R[91],E,E,1,N],[11,R[85],E,E,1,[[[U]],[R[9]]]],[11,R[93],E,E,1,[[["self"]],[T]]],[11,R[92],E,E,1,[[["self"]],[R[94]]]],[11,R[86],E,E,1,[[["self"]],[T]]],[11,R[87],E,E,1,[[["self"]],[R[9]]]],[11,"from",E,E,14,[[[T]],[T]]],[11,"into",E,E,14,[[["self"]],[U]]],[11,R[90],E,E,14,[[["self"]],[T]]],[11,R[91],E,E,14,N],[11,R[85],E,E,14,[[[U]],[R[9]]]],[11,R[93],E,E,14,[[["self"]],[T]]],[11,R[92],E,E,14,[[["self"]],[R[94]]]],[11,R[86],E,E,14,[[["self"]],[T]]],[11,R[87],E,E,14,[[["self"]],[R[9]]]],[11,"from",E,E,43,[[[T]],[T]]],[11,"into",E,E,43,[[["self"]],[U]]],[11,R[85],E,E,43,[[[U]],[R[9]]]],[11,R[93],E,E,43,[[["self"]],[T]]],[11,R[92],E,E,43,[[["self"]],[R[94]]]],[11,R[86],E,E,43,[[["self"]],[T]]],[11,R[87],E,E,43,[[["self"]],[R[9]]]],[11,R[88],E,E,2,[[["self"]],[R[89]]]],[11,"from",E,E,2,[[[T]],[T]]],[11,"into",E,E,2,[[["self"]],[U]]],[11,R[85],E,E,2,[[[U]],[R[9]]]],[11,R[93],E,E,2,[[["self"]],[T]]],[11,R[92],E,E,2,[[["self"]],[R[94]]]],[11,R[86],E,E,2,[[["self"]],[T]]],[11,R[87],E,E,2,[[["self"]],[R[9]]]],[11,R[96],E,E,2,[[["self"]],["fail"]]],[11,"from",E,E,3,[[[T]],[T]]],[11,"into",E,E,3,[[["self"]],[U]]],[11,R[90],E,E,3,[[["self"]],[T]]],[11,R[91],E,E,3,N],[11,R[85],E,E,3,[[[U]],[R[9]]]],[11,R[93],E,E,3,[[["self"]],[T]]],[11,R[92],E,E,3,[[["self"]],[R[94]]]],[11,R[86],E,E,3,[[["self"]],[T]]],[11,R[87],E,E,3,[[["self"]],[R[9]]]],[11,"from",E,E,4,[[[T]],[T]]],[11,"into",E,E,4,[[["self"]],[U]]],[11,R[90],E,E,4,[[["self"]],[T]]],[11,R[91],E,E,4,N],[11,R[85],E,E,4,[[[U]],[R[9]]]],[11,R[93],E,E,4,[[["self"]],[T]]],[11,R[92],E,E,4,[[["self"]],[R[94]]]],[11,R[86],E,E,4,[[["self"]],[T]]],[11,R[87],E,E,4,[[["self"]],[R[9]]]],[11,R[88],E,E,5,[[["self"]],[R[89]]]],[11,"from",E,E,5,[[[T]],[T]]],[11,"into",E,E,5,[[["self"]],[U]]],[11,R[90],E,E,5,[[["self"]],[T]]],[11,R[91],E,E,5,N],[11,R[85],E,E,5,[[[U]],[R[9]]]],[11,R[93],E,E,5,[[["self"]],[T]]],[11,R[92],E,E,5,[[["self"]],[R[94]]]],[11,R[86],E,E,5,[[["self"]],[T]]],[11,R[87],E,E,5,[[["self"]],[R[9]]]],[11,"from",E,E,6,[[[T]],[T]]],[11,"into",E,E,6,[[["self"]],[U]]],[11,R[90],E,E,6,[[["self"]],[T]]],[11,R[91],E,E,6,N],[11,R[85],E,E,6,[[[U]],[R[9]]]],[11,R[93],E,E,6,[[["self"]],[T]]],[11,R[92],E,E,6,[[["self"]],[R[94]]]],[11,R[86],E,E,6,[[["self"]],[T]]],[11,R[87],E,E,6,[[["self"]],[R[9]]]],[11,"from",R[17],E,15,[[[T]],[T]]],[11,"into",E,E,15,[[["self"]],[U]]],[11,R[85],E,E,15,[[[U]],[R[9]]]],[11,R[93],E,E,15,[[["self"]],[T]]],[11,R[92],E,E,15,[[["self"]],[R[94]]]],[11,R[86],E,E,15,[[["self"]],[T]]],[11,R[87],E,E,15,[[["self"]],[R[9]]]],[11,"from",R[95],E,21,[[[T]],[T]]],[11,"into",E,E,21,[[["self"]],[U]]],[11,R[90],E,E,21,[[["self"]],[T]]],[11,R[91],E,E,21,N],[11,R[85],E,E,21,[[[U]],[R[9]]]],[11,R[93],E,E,21,[[["self"]],[T]]],[11,R[92],E,E,21,[[["self"]],[R[94]]]],[11,R[86],E,E,21,[[["self"]],[T]]],[11,R[87],E,E,21,[[["self"]],[R[9]]]],[11,"as_ref",R[0],E,44,[[["self"]],["fail"]]],[11,"fmt",E,E,44,[[["self"],[R[97]]],[R[9],["error"]]]],[11,R[96],E,E,44,[[["self"]],["fail"]]],[11,"from",E,E,44,[[["f"]],["error"]]],[11,"fmt",E,E,44,[[["self"],[R[97]]],[R[9],["error"]]]],[11,"clone",R[95],E,21,[[["self"]],[R[98]]]],[11,R[105],E,E,21,[[],[R[98]]]],[11,R[80],R[0],R[99],8,[[["self"],["str"],[R[4]]],[R[9],["error"]]]],[11,R[81],E,R[100],8,[[["self"],[R[4]]],[R[9],["error"]]]],[11,R[80],E,R[99],9,[[["self"],["str"],[R[4]]],[R[9],["error"]]]],[11,R[81],E,R[100],9,[[["self"],[R[4]]],[R[9],["error"]]]],[11,"write",E,E,12,[[["self"],[T],["u64"],["bool"]],[R[9],["error"]]]],[11,"write",E,E,13,[[["self"],[T],["u64"],["bool"]],[R[9],["error"]]]],[11,"apply",E,E,10,N],[11,R[33],E,E,10,N],[11,R[82],E,E,10,N],[11,"modify",E,E,10,N],[11,"apply",E,E,11,N],[11,R[33],E,E,11,N],[11,R[82],E,E,11,N],[11,"modify",E,E,11,N],[11,"eq",E,E,0,[[["self"],[R[4]]],["bool"]]],[11,"ne",E,E,0,[[["self"],[R[4]]],["bool"]]],[11,"eq",E,E,3,[[["self"],[R[101]]],["bool"]]],[11,"eq",E,E,12,[[["self"],[R[102]]],["bool"]]],[11,"ne",E,E,12,[[["self"],[R[102]]],["bool"]]],[11,"eq",E,E,4,[[["self"],[R[103]]],["bool"]]],[11,"ne",E,E,4,[[["self"],[R[103]]],["bool"]]],[11,"eq",E,E,1,[[["self"],[R[44]]],["bool"]]],[11,"eq",E,E,6,[[["self"],[R[14]]],["bool"]]],[11,"ne",E,E,6,[[["self"],[R[14]]],["bool"]]],[11,"eq",E,E,14,[[["self"],[R[104]]],["bool"]]],[11,"ne",E,E,14,[[["self"],[R[104]]],["bool"]]],[11,"eq",E,E,5,[[["self"],[R[7]]],["bool"]]],[11,R[105],E,E,0,[[],[R[4]]]],[11,R[105],E,E,9,[[],[R[107]]]],[11,R[105],E,E,10,[[],[R[108]]]],[11,R[105],E,E,11,[[],[R[109]]]],[11,R[105],E,E,3,[[],["self"]]],[11,R[105],E,E,4,[[],[R[103]]]],[11,R[105],E,E,13,[[],[R[110]]]],[11,R[105],E,E,1,[[],[R[44]]]],[11,R[105],E,E,6,[[],[R[14]]]],[11,R[105],E,E,14,[[],[R[104]]]],[11,R[105],E,E,5,[[],["self"]]],[11,"cmp",E,E,0,[[["self"],[R[4]]],[R[106]]]],[11,"cmp",E,E,3,[[["self"],[R[101]]],[R[106]]]],[11,"cmp",E,E,12,[[["self"],[R[102]]],[R[106]]]],[11,"cmp",E,E,4,[[["self"],[R[103]]],[R[106]]]],[11,"cmp",E,E,1,[[["self"],[R[44]]],[R[106]]]],[11,"cmp",E,E,6,[[["self"],[R[14]]],[R[106]]]],[11,"cmp",E,E,14,[[["self"],[R[104]]],[R[106]]]],[11,"cmp",E,E,5,[[["self"],[R[7]]],[R[106]]]],[11,"clone",E,E,7,[[["self"]],["argminbase"]]],[11,"clone",E,E,0,[[["self"]],[R[4]]]],[11,"clone",E,E,8,[[["self"]],["argminsloglogger"]]],[11,"clone",E,E,9,[[["self"]],[R[107]]]],[11,"clone",E,E,10,[[["self"]],[R[108]]]],[11,"clone",E,E,11,[[["self"]],[R[109]]]],[11,"clone",E,E,3,[[["self"]],[R[101]]]],[11,"clone",E,E,12,[[["self"]],[R[102]]]],[11,"clone",E,E,4,[[["self"]],[R[103]]]],[11,"clone",E,E,13,[[["self"]],[R[110]]]],[11,"clone",E,E,1,[[["self"]],[R[44]]]],[11,"clone",E,E,6,[[["self"]],[R[14]]]],[11,"clone",E,E,14,[[["self"]],[R[104]]]],[11,"clone",E,E,5,[[["self"]],[R[7]]]],[11,"extend",E,E,0,[[["self"],["i"]]]],[11,R[111],E,E,0,[[["self"],[R[4]]],["option",[R[106]]]]],[11,"lt",E,E,0,[[["self"],[R[4]]],["bool"]]],[11,"le",E,E,0,[[["self"],[R[4]]],["bool"]]],[11,"gt",E,E,0,[[["self"],[R[4]]],["bool"]]],[11,"ge",E,E,0,[[["self"],[R[4]]],["bool"]]],[11,R[111],E,E,3,[[["self"],[R[101]]],["option",[R[106]]]]],[11,R[111],E,E,12,[[["self"],[R[102]]],["option",[R[106]]]]],[11,"lt",E,E,12,[[["self"],[R[102]]],["bool"]]],[11,"le",E,E,12,[[["self"],[R[102]]],["bool"]]],[11,"gt",E,E,12,[[["self"],[R[102]]],["bool"]]],[11,"ge",E,E,12,[[["self"],[R[102]]],["bool"]]],[11,R[111],E,E,4,[[["self"],[R[103]]],["option",[R[106]]]]],[11,"lt",E,E,4,[[["self"],[R[103]]],["bool"]]],[11,"le",E,E,4,[[["self"],[R[103]]],["bool"]]],[11,"gt",E,E,4,[[["self"],[R[103]]],["bool"]]],[11,"ge",E,E,4,[[["self"],[R[103]]],["bool"]]],[11,R[111],E,E,1,[[["self"],[R[44]]],["option",[R[106]]]]],[11,R[111],E,E,6,[[["self"],[R[14]]],["option",[R[106]]]]],[11,"lt",E,E,6,[[["self"],[R[14]]],["bool"]]],[11,"le",E,E,6,[[["self"],[R[14]]],["bool"]]],[11,"gt",E,E,6,[[["self"],[R[14]]],["bool"]]],[11,"ge",E,E,6,[[["self"],[R[14]]],["bool"]]],[11,R[111],E,E,14,[[["self"],[R[104]]],["option",[R[106]]]]],[11,"lt",E,E,14,[[["self"],[R[104]]],["bool"]]],[11,"le",E,E,14,[[["self"],[R[104]]],["bool"]]],[11,"gt",E,E,14,[[["self"],[R[104]]],["bool"]]],[11,"ge",E,E,14,[[["self"],[R[104]]],["bool"]]],[11,R[111],E,E,5,[[["self"],[R[7]]],["option",[R[106]]]]],[11,"fmt",E,E,2,[[["self"],[R[97]]],[R[9]]]],[11,"fmt",E,E,0,[[["self"],[R[97]]],[R[9]]]],[11,"fmt",E,E,1,[[["self"],[R[97]]],[R[9]]]],[11,"fmt",E,E,5,[[["self"],[R[97]]],[R[9]]]],[11,"hash",E,E,0,N],[11,"hash",E,E,6,N],[11,"hash",E,E,14,N],[11,"hash",E,E,5,N],[11,"from_iter",E,E,0,[[["i"]],["self"]]],[11,"fmt",E,E,7,[[["self"],[R[97]]],[R[9]]]],[11,"fmt",E,E,2,[[["self"],[R[97]]],[R[9]]]],[11,"fmt",E,E,0,[[["self"],[R[97]]],[R[9]]]],[11,"fmt",E,E,10,[[["self"],[R[97]]],[R[9]]]],[11,"fmt",E,E,11,[[["self"],[R[97]]],[R[9]]]],[11,"fmt",E,E,3,[[["self"],[R[97]]],[R[9]]]],[11,"fmt",E,E,12,[[["self"],[R[97]]],[R[9]]]],[11,"fmt",E,E,4,[[["self"],[R[97]]],[R[9]]]],[11,"fmt",E,E,1,[[["self"],[R[97]]],[R[9]]]],[11,"fmt",E,E,6,[[["self"],[R[97]]],[R[9]]]],[11,"fmt",E,E,14,[[["self"],[R[97]]],[R[9]]]],[11,"fmt",E,E,5,[[["self"],[R[97]]],[R[9]]]],[11,R[112],E,E,7,[[["self"],["__s"]],[R[9]]]],[11,R[112],E,E,0,[[["self"],["__s"]],[R[9]]]],[11,R[112],E,E,10,[[["self"],["__s"]],[R[9]]]],[11,R[112],E,E,11,[[["self"],["__s"]],[R[9]]]],[11,R[112],E,E,3,[[["self"],["__s"]],[R[9]]]],[11,R[112],E,E,12,[[["self"],["__s"]],[R[9]]]],[11,R[112],E,E,4,[[["self"],["__s"]],[R[9]]]],[11,R[112],E,E,1,[[["self"],["__s"]],[R[9]]]],[11,R[112],E,E,6,[[["self"],["__s"]],[R[9]]]],[11,R[112],E,E,14,[[["self"],["__s"]],[R[9]]]],[11,R[112],E,E,5,[[["self"],["__s"]],[R[9]]]],[11,R[113],E,E,7,[[["__d"]],[R[9]]]],[11,R[113],E,E,0,[[["__d"]],[R[9]]]],[11,R[113],E,E,10,[[["__d"]],[R[9]]]],[11,R[113],E,E,11,[[["__d"]],[R[9]]]],[11,R[113],E,E,3,[[["__d"]],[R[9]]]],[11,R[113],E,E,12,[[["__d"]],[R[9]]]],[11,R[113],E,E,4,[[["__d"]],[R[9]]]],[11,R[113],E,E,1,[[["__d"]],[R[9]]]],[11,R[113],E,E,6,[[["__d"]],[R[9]]]],[11,R[113],E,E,14,[[["__d"]],[R[9]]]],[11,R[113],E,E,5,[[["__d"]],[R[9]]]],[11,"name",E,E,2,[[["self"]],["option",["str"]]]],[11,"cause",E,E,2,[[["self"]],["option",["fail"]]]],[11,R[114],E,E,2,[[["self"]],["option",[R[114]]]]],[11,"from_boxed_compat",E,"Creates an `Error` from `Box<std::error::Error>`.",44,[[["box",["error"]]],["error"]]],[11,R[96],E,"Return a reference to the underlying failure that this…",44,[[["self"]],["fail"]]],[11,"name",E,"Returns the name of the underlying fail.",44,[[["self"]],["option",["str"]]]],[11,"cause",E,"Returns a reference to the underlying cause of this…",44,[[["self"]],["fail"]]],[11,R[114],E,"Gets a reference to the `Backtrace` for this `Error`.",44,[[["self"]],[R[114]]]],[11,"context",E,"Provides context for this `Error`.",44,[[["self"],["d"]],["context"]]],[11,"compat",E,"Wraps `Error` in a compatibility type.",44,[[["self"]],["compat",["error"]]]],[11,"downcast",E,R[115],44,[[["self"]],[R[9],["error"]]]],[11,"find_root_cause",E,"Returns the \"root cause\" of this error - the last value in…",44,[[["self"]],["fail"]]],[11,"iter_causes",E,"Returns a iterator over the causes of this error with the…",44,[[["self"]],["causes"]]],[11,"iter_chain",E,"Returns a iterator over all fails up the chain from the…",44,[[["self"]],["causes"]]],[11,"downcast_ref",E,R[115],44,[[["self"]],["option"]]],[11,"downcast_mut",E,R[115],44,[[["self"]],["option"]]],[11,"root_cause",E,"Deprecated alias to `find_root_cause`.",44,[[["self"]],["fail"]]],[11,"causes",E,"Deprecated alias to `iter_causes`.",44,[[["self"]],["causes"]]],[11,"new",R[17],E,15,[[["l"],["e"],["p"]],[R[18]]]],[11,R[116],E,R[117],17,[[["self"]],[R[18]]]],[11,R[118],E,R[119],18,[[["self"]],[R[18]]]],[11,R[120],E,R[121],19,[[["self"]],[R[18]]]],[11,"new",R[95],"Create a new empty `PerturbationVector`",21,[[],[R[98]]]],[11,"add",E,"Add an index `x_idx` and the corresponding function…",21,[[["self"],["usize"],["vec",["usize"]]],[R[98]]]]],"p":[[3,"ArgminKV"],[3,R[122]],[4,R[123]],[4,R[20]],[4,R[124]],[4,R[125]],[4,R[126]],[3,R[127]],[3,R[128]],[3,R[129]],[3,R[130]],[3,R[131]],[3,R[19]],[3,R[132]],[3,R[133]],[3,R[134]],[8,R[135]],[8,R[136]],[8,R[137]],[8,R[138]],[8,R[139]],[3,R[140]],[8,R[141]],[8,R[142]],[8,R[143]],[8,R[144]],[8,R[145]],[8,R[146]],[8,R[147]],[8,R[148]],[8,R[149]],[8,R[150]],[8,R[151]],[8,R[152]],[8,R[153]],[8,R[154]],[8,R[155]],[8,R[156]],[8,R[157]],[8,"ArgminOp"],[8,R[158]],[8,R[159]],[8,R[160]],[3,R[161]],[3,"Error"]]};
initSearch(searchIndex);addSearchOptions(searchIndex);